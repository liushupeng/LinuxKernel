# 中断处理

-   [Linux 中断（IRQ/softirq）基础：原理及内核实现](https://arthurchiao.art/blog/linux-irq-softirq-zh/) 

什么是中断？中断就是当软件或者硬件需要使用 CPU 时引发的事件（event），可以将中断想象成硬件或软件产生（或“触发”）的事件。

-   硬件中断是由硬件设备触发的，以此通知内核发生了特定的事件。一个常见的例子是网卡收到数据包时触发的硬中断。
-   软件中断是由执行中的程序触发的。在 x86-64 系统上，软件中断可以通过 **`int`** 指令触发。

>   ？？中断编号，中断项
>
>   ？？ int 0x80 中的entry_INT80_compat() 函数是如何被调用的？

## 1.1 中断描述符表

中断描述符表会在系统启动的时候初始化，初始化链路也比较简洁。

### 1.1.1 secondary_startup_64

`arch/x86/kernel/head_64.S:secondary_startup_64()` 是 Linux 内核启动过程中用来启动其他 CPU（即非 boot CPU）的入口函数，属于 SMP（对称多处理）初始化 的一部分。

```asm
SYM_DATA(initial_code,  .quad x86_64_start_kernel)

SYM_CODE_START(secondary_startup_64)   ; 这个函数很长，大部分看不太懂，只展示与中断描述符相关的部分
...
    pushq   $.Lafter_lret              ; put return address on stack for unwinder
    xorl    %ebp, %ebp                 ; clear frame pointer
    movq    initial_code(%rip), %rax   ; 无论如何，x86_64_start_kernel() 会被调用到
    pushq   $__KERNEL_CS               ; set correct cs
    pushq   %rax                       ; target address in negative space
    lretq
.Lafter_lret:
    ANNOTATE_NOENDBR
SYM_CODE_END(secondary_startup_64)
```

在 x86_64 多核系统中，只有一个 CPU（Boot Processor，BSP）会最先启动并执行内核的早期初始化流程，其他 CPU（Application Processors，APs）是“睡着的”。当 BSP 初始化完成后，会通过一种机制（通常是 APIC）将这些 AP 唤醒，AP 唤醒后的第一件事就是执行 `secondary_startup_64`。一个简化版的流程如下

```c
BSP CPU -> start_kernel() -> smp_init() -> smp_prepare_cpus() -> smp_boot_secondary() ---
                                         /* 准备唤醒其他 CPU */      /* start AP */       |
                                                                                        |
          CPU 启动完成，进入调度系统 <- start_secondary() <- secondary_startup_64() <- <AP CPU 被唤醒>
                                                   /* 此处调用 secondary_startup_64*/
```

### 1.1.2 x86_64_start_kernel

`arch/x86/kernel/head64.c:x86_64_start_kernel()` 为调用 `start_kernel()` 做好 x86_64 架构相关的早期准备（内存管理、CPU 环境等）

```c
asmlinkage __visible void __init x86_64_start_kernel(char * real_mode_data)
{
    ...
    x86_64_start_reservations(real_mode_data);
}
```

### 1.1.3 x86_64_start_reservations

`arch/x86/kernel/head64.c:x86_64_start_reservations()` 根据 bootloader（如 GRUB）传入的启动信息（`boot_params`），初始化和保留关键的物理内存区域，为后续内核启动和物理内存管理做好准备。

```c
void __init x86_64_start_reservations(char *real_mode_data)
{
    ...
    start_kernel();
}
```

### 1.1.4 start_kernel

`init/main.c:start_kernel()` 是 Linux 内核启动流程中第一个执行的“通用架构无关”C 函数，它负责初始化整个内核子系统，并最终进入用户空间。对这个函数更详细的介绍移步 `13.2 start_kernel` 章节

```c
asmlinkage __visible void __init __no_sanitize_address start_kernel(void)
{
    ...
    trap_init();
    ...
    init_IRQ();         // 从函数名来看是各种init，后续不同子模块应该都会来到这，先mark
    softirq_init();
    ...
}
```

### 1.1.5 trap_init

`arch/x86/kernel/traps.c:trap_init()` 是用于设置 x86 架构的异常（CPU trap）向量表，包括如 0 除异常、页错误、通用保护错误等，是中断/异常处理初始化的一部分。

```c
void __init trap_init(void)
{
    setup_cpu_entry_areas();        // 初始化 cpu_entry_area 区域（包括 per-CPU 异常栈等）
    sev_es_init_vc_handling();      // 如果是 SEV-ES 虚拟化环境，初始化 VC（#VC）异常处理页
    cpu_init_exception_handling();  // 初始化 TSS/IST 栈，为异常处理器提供可靠栈空间
    idt_setup_traps();              // 安装常规的异常陷阱表（设置 IDT 向量）
    cpu_init();                     // 调用通用的 CPU 初始化函数（处理器特性探测）
}
```

### 1.1.6 idt_setup_traps

`arch/x86/kernel/idt.c:idt_setup_traps()` 把标准 x86 trap（CPU 异常）注册到 IDT 表中

```c
#define IA32_SYSCALL_VECTOR     0x80

static gate_desc idt_table[IDT_ENTRIES] __page_aligned_bss;

static const __initconst struct idt_data def_idts[] = {
    INTG(X86_TRAP_DE,       asm_exc_divide_error),
    ...
    SYSG(IA32_SYSCALL_VECTOR,   entry_INT80_compat),     // entry_INT80_compat 是系统调用对应的回调函数
}                                                        // 后续调用逻辑可以看7.1.1章节

void __init idt_setup_traps(void)
{
    idt_setup_from_table(idt_table, def_idts, ARRAY_SIZE(def_idts), true);
}
```





## 🧬 和 “软中断”（softirq）有什么关系？

>   虽然名字相似，**`int 0x80` 中的“软中断”**和内核中的 **softirq（软中断机制）**是两个完全不同的概念。



| 项目     | `int 0x80`             | `softirq`                            |
| -------- | ---------------------- | ------------------------------------ |
| 属于     | CPU 指令触发的中断     | Linux 内核的中断下半部机制           |
| 使用场景 | 用户态程序请求系统调用 | 网络收包、tasklet等延迟处理          |
| 权限转换 | 会从用户态切到内核态   | 内核内调度，仍在内核态               |
| 示例     | `int 0x80`、`syscall`  | `raise_softirq()`, `net_rx_action()` |









## 1.2 顶半部和底半部

为解决中断响应时间长的问题，Linux将中断处理例程分成两部分：顶半部和底半部。

**顶半部**：是实际响应中断的例程，也就是用 request_irq 注册的中断例程

**底半部**：是一个被顶半部调度，并在稍后更安全的时间内执行的例程

顶半部处理例程和底半部处理例程之间最大的不同，就是当底半部处理例程执行时，所有的中断都是打开的——这就是所谓的在更安全时间内运行。典型的情况是顶半部保存设备的数据到一个设备特定的缓冲区并调度它的底半部，然后退出，这个操作是非常快的。然后，底半部执行其他必要的工作，例如唤醒进程、启动另外的I/O操作等等。这种方式允许在底半部工作期间，顶半部还可以继续为新的中断服务。

顶半部和底半部一般通过tasklet或workqueue来实现。关于这两者的实现可以移步 `12.3` 章节。一个中断处理的实现：[interrupt/parallel_hardirq.c](https://github.com/liushupeng/LinuxKernel/blob/master/interrupt/parallel_hardirq.c) 